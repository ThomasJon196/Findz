<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Findz.</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"/>
    <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
            rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        #goBackButton {
            position: absolute;
            left: 2%;
            top: 2%;
            z-index: 999;
            border-radius: 5px;
            border: none;
            background: rgba(54, 88, 48, 0.85);
            color: white;
            padding: 8px 10px;;
        }

        #nearbyListForm {
            position: absolute;
            left: 2%;
            bottom: 2%;
            z-index: 999;
            border-radius: 5px;
            background: rgba(54, 88, 48, 0.85);
            color: white;
            padding: 10px;
        }

        #openAddPointFormButton {
            background-color: #363636;
            color: white;
            padding: 10px 10px;
            border: none;
            border-radius: 5px;
            opacity: 0.8;
            position: fixed;
            top: 2%;
            right: 2%;
        }

        #openAddPointForm {
            display: none;
            position: fixed;
            bottom: 50%;
            left: 50%;
            top: 1%;
            right: 1%;
            z-index: 9;
        }

        #openPointForm {
            display: none;
            position: fixed;
            bottom: 50%;
            right: 50%;
            z-index: 9;
        }

        .form-container {
            max-width: 300px;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
        }

        .form-container input[type=text] {
            width: 100%;
            height: 40px;
            padding-left: 4px;
            margin: 5px 0 22px 0;
            background-color: #F9F9F9;
            border-radius: 5px;
            border: 1px solid #DADADA;
        }

        .btn {
            background-color: #365830;
            color: white;
            padding: 10px 12px;
            border: none;
            border-radius: 5px;
        }

        .cancel {
            background-color: red;
        }


    </style>
</head>

<body>
<!-- The AR scene with AR.js configuration -->
<a-scene vr-mode-ui="enabled: false" arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
         id="a-scene" cursor='rayOrigin: mouse' raycaster='near: 0; far: 50000'>
    <!-- Container for the 3D object to be defined later -->
    <a-entity id="container">
        <!-- The 3D object will be defined here -->
    </a-entity>
    <!-- The camera used for AR with GPS support -->
    <a-camera gps-camera rotation-reader far="100000"></a-camera>
</a-scene>

<!-- Button to go back to the previous page -->
<button id="goBackButton" onclick="window.history.go(-1); return false;">
    zurück
</button>

<!-- List of nearby points of interest -->
<div id="nearbyListForm">
    In deiner Nähe (<40m):
    <ul id="nearbyList" style='list-style-type:square;'></ul>
</div>

<!-- Button to open the form to add a new point of interest -->
<button id="openAddPointFormButton" onclick="openForm()">
    <span class="material-symbols-outlined">
        add_location_alt
    </span>
</button>

<!-- The form to display details about a point of interest -->
<div id="openPointForm">
    <div class="form-container">
        <h3 id="titlePoint"></h3>
        <p id="textPoint"></p>

        <button class="btn" onclick="closePoint()">Schließen</button>
    </div>
</div>

<!-- The form to add a new point of interest -->
<div id="openAddPointForm">
    <div class="form-container">
        <h3>Markierung setzen</h3>

        <label for="title"><b>Name</b></label>
        <input type="text" placeholder="Name" id="title">

        <label for="description"><b>Beschreibung</b></label>
        <input type="text" placeholder="Beschreibung" id="description">

        <button class="btn" onclick="safeMarker()">Speichern</button>
        <button type="button" class="btn cancel" onclick="closeForm()">Verwerfen</button>
    </div>
</div>
</body>

<script>
    // An array to store all points of interest
    let points = [];

    // An array to store the list of nearby friends
    let nearbyFriendList = [];

    // The current user's GPS position
    let ownPosition;

    // Initialize a socket connection to the server
    var socket = io.connect('https://' + document.domain + ':' + location.port);

    // Function to be called when the user's GPS position is successfully obtained
    const successCallback = (position) => {
        // Emit an update to the server with the user's name and GPS coordinates
        socket.emit('update', JSON.stringify({
            "name": '{{user}}',
            "latitude": position.coords.latitude,
            "longitude": position.coords.longitude,
        }))
        // Store the user's position for later use
        ownPosition = position;
    };

    // Function to be called when there is an error obtaining
    const errorCallback = (error) => {
        console.log(error);
    };

    // Start tracking user's position and sending updates to the server
    navigator.geolocation.watchPosition(successCallback, errorCallback)

    // Send a join message to the server with user's name and current group
    socket.emit('join', JSON.stringify({
        "name": '{{user}}',
        "current_group": '{{current_group}}'
    }))

    // Listen for a redirect message from the server and redirect the user to the specified destination
    socket.on('redirect', function (destination) {
        window.location.href = destination;
    });

    // Listen for an answer message from the server and update the friend and point lists accordingly
    socket.on('answer', function (msg) {
        // Parse the friend and point lists from the message
        let friendListNew = JSON.parse(msg)[0].filter(element => element['name'] !== '{{user}}');
        let pointListNew = JSON.parse(msg)[1];

        // Clear the existing 3D scene
        document.querySelector('#container').innerHTML = '';

        // Update the nearbyFriendList based on the new friend list
        friendListNew.forEach(newFriend => {
            if (typeof newFriend.name != "undefined") {
                // Calculate the distance between the new friend and the user
                let distance = getDistance(newFriend.latitude, newFriend.longitude);
                // If the new friend is within 40m and not already in the nearbyFriendList, add them to the list and update the UI
                if ((distance < 0.04) && !nearbyFriendList.includes(newFriend.name)) {
                    nearbyFriendList.push(newFriend.name)
                    updateNearbyList();
                    // If the new friend is more than 40m away and already in the nearbyFriendList, remove them from the list and update the UI
                } else if ((distance > 0.04) && nearbyFriendList.includes(newFriend.name)) {
                    for (let i = 0; i < nearbyFriendList.length; i++) {
                        if (nearbyFriendList[i].localeCompare(newFriend.name + " ")) {
                            nearbyFriendList.splice(i, 1);
                            updateNearbyList();
                            createFriendEntity(newFriend);
                            break;
                        }
                    }
                    // If the new friend is already in the nearbyFriendList, do nothing
                } else if (nearbyFriendList.includes(newFriend.name)) {
                    // If the new friend is not in the nearbyFriendList, create a new entity for them in the 3D scene
                } else {
                    createFriendEntity(newFriend);
                }
            }
        });

        // Update the point list based on the new point list
        pointListNew.forEach(newPoint => {
            // Check if the new point already exists in the point list and update it if it does
            for (let i = 0; i < points.length; i++) {
                if (0 === points[i].title.localeCompare(newPoint.title)) {
                    updatePoint(newPoint)
                    //console.log("updated point: ", newPoint)
                    return;
                }
            }
            // If the new point doesn't exist in the point list, add it and create a new entity for it in the 3D scene
            points.push(newPoint);
            console.log("created point: ", newPoint);
            createPointEntity(newPoint);
        });
    });


    function checkNearbyFriend(newFriend) {
        let distance = getDistance(newFriend.latitude, newFriend.longitude);

        if ((distance < 0.04) && !nearbyFriendList.includes(newFriend.name)) {
            nearbyFriendList.push(newFriend.name)
            updateNearbyList();
            return true;
        } else if ((distance > 0.04) && nearbyFriendList.includes(newFriend.name)) {
            for (let i = 0; i < nearbyFriendList.length; i++) {
                if (nearbyFriendList[i].localeCompare(newFriend.name + " ")) {
                    nearbyFriendList.splice(i, 1);
                    break;
                }
            }
            updateNearbyList();
            return false;
        } else if (nearbyFriendList.includes(newFriend.name)) {
            return true;
        }
        return false;
    }


    function createFriendEntity(newFriend) {
        let distance = getDistance(newFriend.latitude, newFriend.longitude);
        let scale = getIndividualScale(distance, 130);

        // Create an <a-text> element to display the distance to the new friend
        let userText = document.createElement("a-text");
        userText.setAttribute("value", getDistanceText(distance));
        userText.setAttribute('position', 0 + " " + (-scale / 1.41) + " " + 0);
        userText.setAttribute("scale", scale + " " + scale + " " + scale);
        userText.setAttribute("align", "center");

        // Create an <a-circle> element to display the new friend's image
        let userImage = document.createElement("a-circle");
        userImage.setAttribute('align', 'center');
        userImage.setAttribute("material", "src: " + newFriend.bild);
        userImage.setAttribute("scale", (scale / 1.6) + " " + (scale / 1.6) + " " + (scale / 1.6));

        // Create a parent <a-entity> element to group the text and image elements and position it on the map
        let root = document.createElement("a-entity");
        root.setAttribute("maxDistance", "5000000");
        root.setAttribute("look-at", "[gps-camera]");
        root.setAttribute("gps-entity-place", "latitude:" + newFriend.latitude + "; longitude:" + newFriend.longitude);
        root.appendChild(userImage);
        root.appendChild(userText);

        let element = document.querySelector('#container');
        element.appendChild(root);
    }

    function createPointEntity(newPoint) {
        // Calculate the distance from the user to the new point
        let distance = getDistance(newPoint.latitude, newPoint.longitude);

        // Scale the size of the point based on its distance from the user
        let scale = getIndividualScale(distance, 200);

        // Create a text element to display the title of the point and its distance from the user
        let pointText = document.createElement("a-text");
        pointText.setAttribute("id", newPoint.title + "Text");
        pointText.setAttribute("value", newPoint.title + getDistanceText(distance));
        pointText.setAttribute("align", "center");
        pointText.innerText = newPoint.title;
        pointText.setAttribute('position', 0 + " " + (scale * 1.5) + " " + 0)
        pointText.setAttribute("scale", (scale * 1.3) + " " + (scale * 1.3) + " " + (scale * 1.3))

        // Create a marker for the point using a cone and a sphere
        let marker = document.createElement("a-entity");
        marker.setAttribute("id", newPoint.title + "Marker");
        marker.innerHTML = '<a-cone position="0 0 0" rotation="-180 0 0" height="1.2" radius-bottom="1.2" color="#FF0000"></a-cone> <a-sphere position="0 1.68 0" radius="1.6" color="#FF0000" rotation="180 0 0"></a-sphere>'
        marker.setAttribute("scale", (scale / 2.5) + " " + (scale / 2.5) + " " + (scale / 2.5));
        marker.setAttribute("position", 0 + " " + (scale * 2) + " " + 0);

        // Add a click event listener to the marker to open the point details
        marker.addEventListener('click', function (e) {
            openPoint(newPoint, e);
        })

        // Create a text entity to display the point title and distance
        let root = document.createElement("a-entity");
        root.setAttribute("id", newPoint.title);
        root.setAttribute("maxDistance", "5000000");
        root.setAttribute("look-at", "[gps-camera]");
        root.setAttribute("gps-entity-place", "latitude:" + newPoint.latitude + "; longitude:" + newPoint.longitude);
        root.appendChild(marker);
        root.appendChild(pointText);

        // Add the root entity to the scene
        let element = document.querySelector('a-scene');
        element.appendChild(root);
    }

    // This function updates a point on a map with new data
    function updatePoint(newPoint) {
        // Calculate the distance between the new point and the current location
        let distance = getDistance(newPoint.latitude, newPoint.longitude);

        // Calculate the scaling factor for the point based on its distance from the current location
        let scale = getIndividualScale(distance, 200);

        // Find the root element for the point and update its position
        let root = document.getElementById(newPoint.title);
        root.setAttribute("gps-entity-place", "latitude:" + newPoint.latitude + "; longitude:" + newPoint.longitude);

        // Find the element for the point's text and update its text and position
        let pointText = document.getElementById(newPoint.title + "Text");
        pointText.setAttribute("value", newPoint.title + getDistanceText(distance));
        pointText.innerText = newPoint.title;
        pointText.setAttribute('position', 0 + " " + (scale * 1.5) + " " + 0)
        pointText.setAttribute("scale", (scale * 1.3) + " " + (scale * 1.3) + " " + (scale * 1.3))

        // Find the element for the point's marker and update its scale and position
        let marker = document.getElementById(newPoint.title + "Marker")
        marker.setAttribute("scale", (scale / 2.5) + " " + (scale / 2.5) + " " + (scale / 2.5))
        marker.setAttribute("position", 0 + " " + (scale * 2) + " " + 0)
    }

    // This function updates the list of nearby friends
    function updateNearbyList() {
        // Find the element for the nearby friends list and clear its contents
        let nearbyList = document.querySelector('#nearbyList')
        nearbyList.innerHTML = "";
        // Loop through each friend in the nearby friend list and create a list item element for them
        for (index in nearbyFriendList) {
            const nearFriend = document.createElement('li');
            nearFriend.innerText = nearbyFriendList[index];
            nearbyList.appendChild(nearFriend);
        }
    }

    // This function is called when a map point is clicked.
    // It displays the title and text of the point in a form on the page.
    function openPoint(point, e) {
        e.stopPropagation(); // Stop the click event from propagating to the map
        console.log("point : " + point["title"]);

        // Update the form with the point's title and text
        document.getElementById("titlePoint").innerHTML = point["title"];
        document.getElementById("textPoint").innerHTML = point["text"];
        document.getElementById("openPointForm").style.display = "block";
    }

    // This function is called when the "Close" button on the point form is clicked.
    // It hides the point form.
    function closePoint() {
        document.getElementById("openPointForm").style.display = "none";
    }

    // This function is called when the "Add Point" button on the page is clicked.
    // It displays a form for the user to input a new map point.
    function openForm() {
        document.getElementById("openAddPointForm").style.display = "block";
    }

    // This function is called when the "Cancel" button on the new point form is clicked.
    // It clears the form inputs and hides the new point form.
    function closeForm() {
        document.getElementById("title").value = "";
        document.getElementById("description").value = "";
        document.getElementById("openAddPointForm").style.display = "none";
    }

    // This function is called when the "Save" button on the new point form is clicked.
    // It sends a request to the server to save the new point, and then clears the form inputs and hides the form.
    function safeMarker() {
        let title = document.getElementById("title").value;
        let description = document.getElementById("description").value;

        // Ensure that the user has entered a title and description for the new point
        if (title === "") {
            alert("Bitte Namen eingeben!");
            return;
        }
        if (description === "") {
            alert("Bitte Beschreibung eingeben!");
            return;
        }

        // Send a POST request to the server to save the new point
        fetch("https://" + document.domain + ":" + location.port + "/save_point", {
            method: "POST",
            body: JSON.stringify({
                "title": title,
                "text": description,
                "latitude": ownPosition.coords.latitude,
                "longitude": ownPosition.coords.longitude
            })
            ,
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        }).then(response => response.json())
            .then(data => {
                console.log("Response received:", data);
            })
            .catch(error => {
                console.error("Error occurred:", error);
            });
        console.log("added new point" + title);

        // Clear the form inputs and hide the form
        closeForm();
    }


    function getDistanceText(distance) {
        if (distance > 1) {
            return " " + distance + " km";
        } else {
            return " " + (distance * 1000) + " m";
        }
    }

    //helperfunctions for calculation
    function getDistance(latitude, longitude) {
        return PythagorasEquirectangular(latitude, longitude, ownPosition.coords.latitude, ownPosition.coords.longitude);
    }

    function getIndividualScale(distance, scale) {
        // This function calculates the scale of a marker based on its distance from the user's location
        // If the distance is greater than 2.5 km, the marker will have a size of 2.5 times the original scale
        // If the distance is less than 0.5 km, the marker will have a size of 0.6 times the original scale
        if (distance > 2.5) {
            scale *= (1 + (distance - 2.5));
        } else if (distance < 0.5) {
            scale *= (0.6 - (0.5 - distance));
        }
        return scale;
    }

    function Deg2Rad(deg) {
        // This function converts degrees to radians
        return deg * Math.PI / 180;
    }

    function PythagorasEquirectangular(lat1, lon1, lat2, lon2) {
        // This function calculates the distance between two points on a sphere using the Pythagorean theorem and the equirectangular approximation
        // It takes the latitude and longitude of two points as input and returns the distance between them in kilometers
        lat1 = Deg2Rad(lat1);
        lat2 = Deg2Rad(lat2);
        lon1 = Deg2Rad(lon1);
        lon2 = Deg2Rad(lon2);
        var R = 6371; // km
        var x = (lon2 - lon1) * Math.cos((lat1 + lat2) / 2);
        var y = (lat2 - lat1);
        var d = Math.sqrt(x * x + y * y) * R;
        return d.toFixed(2);
    }


    /*
    friendListNew.forEach(newFriend => {
        if (typeof newFriend.name != "undefined") {

            let distance = getDistance(newFriend.latitude, newFriend.longitude);
            if ((distance < 0.04) && !nearbyFriendList.includes(newFriend.name)) {
                nearbyFriendList.push(newFriend.name)
                updateNearbyList();

            } else if ((distance > 0.04) && nearbyFriendList.includes(newFriend.name)) {
                for (let i = 0; i < nearbyFriendList.length; i++) {
                    if (nearbyFriendList[i].localeCompare(newFriend.name + " ")) {
                        nearbyFriendList.splice(i, 1);
                        break;
                    }
                }
                updateNearbyList();
                createFriendEntity(newFriend);
            } else if (nearbyFriendList.includes(newFriend.name)) {
            } else {
                createFriendEntity(newFriend);
            }
        }

    });
*/
</script>

</html>
